// Copyright IBM Corp. 2014, 2025
// SPDX-License-Identifier: MPL-2.0

package config

import (
	"testing"
)

func TestGetCopyrightHeader(t *testing.T) {
	tests := []struct {
		name     string
		config   Config
		ext      string
		expected string
	}{
		{
			name: "IBM style with year range",
			config: Config{
				Copyright: Copyright{
					Holder:      "IBM Corp.",
					StartYear:   2014,
					CurrentYear: 2025,
					Format:      "Copyright {{.Holder}} {{.StartYear}}, {{.CurrentYear}}",
				},
				Files: Files{
					CommentStyles: map[string]string{".go": "//"},
				},
			},
			ext:      ".go",
			expected: "// Copyright IBM Corp. 2014, 2025",
		},
		{
			name: "HashiCorp style no year",
			config: Config{
				Copyright: Copyright{
					Holder: "HashiCorp, Inc.",
					Format: "Copyright (c) {{.Holder}}",
				},
				Files: Files{
					CommentStyles: map[string]string{".go": "//"},
				},
			},
			ext: ".go",
		},
		{
			name: "Shell script with hash comment",
			config: Config{
				Copyright: Copyright{
					Holder:      "Acme Corp",
					CurrentYear: 2025,
					Format:      "Copyright {{.CurrentYear}} {{.Holder}}",
				},
				Files: Files{
					CommentStyles: map[string]string{".sh": "#"},
				},
			},
			ext:      ".sh",
			expected: "# Copyright 2025 Acme Corp",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := tt.config.GetCopyrightHeader(tt.ext)
			if err != nil {
				t.Fatalf("GetCopyrightHeader() error = %v", err)
			}
			if result != tt.expected {
				t.Errorf("GetCopyrightHeader() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestShouldReplace(t *testing.T) {
	config := Config{
		Detection: Detection{
			ReplacePatterns: []string{},
		},
	}

	tests := []struct {
		line     string
		expected bool
	}{
		{"// Copyright IBM Corp. 2014, 2025", false},
		{"package main", false},
	}

	for _, tt := range tests {
		t.Run(tt.line, func(t *testing.T) {
			result := config.ShouldReplace(tt.line)
			if result != tt.expected {
				t.Errorf("ShouldReplace(%q) = %v, want %v", tt.line, result, tt.expected)
			}
		})
	}
}

func TestIsGenerated(t *testing.T) {
	config := Config{
		Detection: Detection{
			SkipGenerated: true,
			GeneratedPatterns: []string{
				"Code generated",
				"DO NOT EDIT",
			},
		},
	}

	tests := []struct {
		name     string
		lines    []string
		expected bool
	}{
		{
			name:     "generated file first line",
			lines:    []string{"// Code generated by protoc-gen-go", "package main"},
			expected: true,
		},
		{
			name:     "generated file second line",
			lines:    []string{"package main", "// DO NOT EDIT"},
			expected: true,
		},
		{
			name:     "normal file",
			lines:    []string{"package main", "import \"fmt\""},
			expected: false,
		},
		{
			name:     "empty file",
			lines:    []string{},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := config.IsGenerated(tt.lines)
			if result != tt.expected {
				t.Errorf("IsGenerated() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestIsThirdPartyCopyright_Precedence(t *testing.T) {
	config := Config{
		Detection: Detection{
			ReplacePatterns: []string{},
		},
		ThirdParty: ThirdParty{
			Patterns: []string{
				"Copyright.*[a-zA-Z0-9].*", // General pattern
			},
		},
	}

	tests := []struct {
		name     string
		line     string
		expected bool
	}{
		{
			name:     "HashiCorp copyright - should be replacement, not third-party",
			expected: false, // Not third-party because it matches replacement
		},
		{
			name:     "Oracle copyright - should be third-party",
			line:     "// Copyright Oracle Corp.",
			expected: true, // Third-party because doesn't match replacement
		},
		{
			name:     "Microsoft copyright - should be third-party",
			line:     "// Copyright Microsoft Corp.",
			expected: true,
		},
		{
			name:     "Non-copyright line",
			line:     "package main",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := config.IsThirdPartyCopyright(tt.line)
			if result != tt.expected {
				t.Errorf("IsThirdPartyCopyright(%q) = %v, want %v", tt.line, result, tt.expected)
			}
		})
	}
}

func TestConfig_shouldProcessPath(t *testing.T) {
	tests := []struct {
		name         string
		includePaths []string
		excludePaths []string
		file         string
		want         bool
	}{
		{
			name: "no filters - process everything",
			file: "internal/service/ec2/service.go",
			want: true,
		},
		{
			name:         "include only - match",
			includePaths: []string{"internal/service/[a-g]*"},
			file:         "internal/service/ec2/service.go",
			want:         true,
		},
		{
			name:         "include only - no match",
			includePaths: []string{"internal/service/[a-g]*"},
			file:         "internal/service/s3/service.go",
			want:         false,
		},
		{
			name:         "exclude only - match exclude",
			excludePaths: []string{"internal/service/s3*"},
			file:         "internal/service/s3/service.go",
			want:         false,
		},
		{
			name:         "exclude only - no match exclude",
			excludePaths: []string{"internal/service/s3*"},
			file:         "internal/service/ec2/service.go",
			want:         true,
		},
		{
			name:         "both - match include and exclude",
			includePaths: []string{"internal/service/*"},
			excludePaths: []string{"internal/service/s3*"},
			file:         "internal/service/s3/service.go",
			want:         false,
		},
		{
			name:         "both - match include, no exclude",
			includePaths: []string{"internal/service/*"},
			excludePaths: []string{"internal/service/s3*"},
			file:         "internal/service/ec2/service.go",
			want:         true,
		},
		{
			name:         "doublestar exclude - match",
			excludePaths: []string{".github/**"},
			file:         ".github/workflows/ci.yml",
			want:         false,
		},
		{
			name:         "doublestar exclude - no match",
			excludePaths: []string{".github/**"},
			file:         "internal/service/ec2/service.go",
			want:         true,
		},
		{
			name:         "doublestar include - match",
			includePaths: []string{"internal/**/test*"},
			file:         "internal/service/ec2/test_helper.go",
			want:         true,
		},
		{
			name:         "doublestar include - no match",
			includePaths: []string{"internal/**/test*"},
			file:         "internal/service/ec2/service.go",
			want:         false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &Config{
				Files: Files{
					IncludePaths: tt.includePaths,
					ExcludePaths: tt.excludePaths,
				},
			}
			if got := c.shouldProcessPath(tt.file); got != tt.want {
				t.Errorf("shouldProcessPath() = %v, want %v", got, tt.want)
			}
		})
	}
}
