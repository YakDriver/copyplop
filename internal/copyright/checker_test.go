// Copyright IBM Corp. 2014, 2026
// SPDX-License-Identifier: MPL-2.0

package copyright

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/YakDriver/copyplop/internal/config"
)

func TestChecker_checkFile(t *testing.T) {
	// Create temp directory for test files
	tmpDir := t.TempDir()

	cfg := &config.Config{
		Copyright: config.Copyright{
			Holder:      "IBM Corp.",
			StartYear:   2014,
			CurrentYear: 2025,
			Format:      "Copyright {{.Holder}} {{.StartYear}}, {{.CurrentYear}}",
		},
		Files: config.Files{
			CommentStyles: map[string]string{".go": "//", ".sh": "#"},
		},
		Detection: config.Detection{
			SkipGenerated:     true,
			GeneratedPatterns: []string{"Code generated"},
			MaxScanLines:      20,
			RequireAtTop:      true,
		},
	}

	checker := NewChecker(cfg)

	tests := []struct {
		name        string
		filename    string
		content     string
		expectIssue bool
	}{
		{
			name:     "correct header",
			filename: "good.go",
			content: `// Copyright IBM Corp. 2014, 2025
// SPDX-License-Identifier: MPL-2.0

// package main`,
			expectIssue: false,
		},
		{
			name:     "missing header",
			filename: "bad.go",
			content: `package main

func main() {}`,
			expectIssue: true,
		},
		{
			name:     "generated file",
			filename: "gen.go",
			content: `// Code generated by protoc-gen-go
package main`,
			expectIssue: false,
		},
		{
			name:     "shell script with shebang",
			filename: "script.sh",
			content: `#!/bin/bash
# Copyright IBM Corp. 2014, 2025

echo "hello"`,
			expectIssue: false,
		},
		{
			name:     "copyright deep in file beyond scan limit",
			filename: "deep.go",
			content: `package main

// Line 3
// Line 4
// Line 5
// Line 6
// Line 7
// Line 8
// Line 9
// Line 10
// Line 11
// Line 12
// Line 13
// Line 14
// Line 15
// Line 16
// Line 17
// Line 18
// Line 19
// Line 20
// Line 21
// Line 22
// Copyright IBM Corp. 2014, 2025

func main() {}`,
			expectIssue: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			filePath := filepath.Join(tmpDir, tt.filename)
			err := os.WriteFile(filePath, []byte(tt.content), 0644)
			if err != nil {
				t.Fatalf("Failed to write test file: %v", err)
			}

			issue := checker.checkFile(filePath)
			hasIssue := issue != nil

			if hasIssue != tt.expectIssue {
				t.Errorf("checkFile() issue = %v, want %v", hasIssue, tt.expectIssue)
				if issue != nil {
					t.Errorf("Issue: %s", issue.Problem)
				}
			}
		})
	}
}
